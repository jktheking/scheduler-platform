package com.acme.scheduler.api.controller;

import com.acme.scheduler.api.dto.ApiResponse;
import com.acme.scheduler.api.dto.PageResponse;
import com.acme.scheduler.api.dto.execution.CommandAcceptedDto;
import com.acme.scheduler.api.dto.execution.StartWorkflowInstanceRequest;
import com.acme.scheduler.api.dto.execution.WorkflowInstanceDto;
import com.acme.scheduler.adapter.inmemory.InMemoryCommandBus;
import com.acme.scheduler.application.usecase.StartWorkflowCommand;
import com.acme.scheduler.application.usecase.StartWorkflowUseCase;
import com.acme.scheduler.domain.execution.*;
import com.acme.scheduler.domain.ids.*;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping("/dolphinscheduler/projects/{projectCode}/executors")
@Tag(name = "Workflow Execution APIs")
public class WorkflowExecutionController {

  private final StartWorkflowUseCase startWorkflowUseCase;
  private final InMemoryCommandBus inMemoryCommandBus;

  public WorkflowExecutionController(StartWorkflowUseCase startWorkflowUseCase, InMemoryCommandBus inMemoryCommandBus) {
    this.startWorkflowUseCase = startWorkflowUseCase;
    this.inMemoryCommandBus = inMemoryCommandBus;
  }

  @PostMapping("/start-process-instance")
  public ApiResponse<CommandAcceptedDto> start(@PathVariable long projectCode,
                                              @Valid @RequestBody StartWorkflowInstanceRequest req) {
    // Minimal parse + defaults; richer validation comes in Step 2+.
    StartWorkflowCommand cmd = new StartWorkflowCommand(
        new WorkflowCode(req.processDefinitionCode()),
        1,
        req.scheduleTime() == null || req.scheduleTime().isBlank() ? null : Instant.parse(req.scheduleTime()),
        parseFailure(req.failureStrategy()),
        parseWarning(req.warningType()),
        req.warningGroupId() == null ? 0L : req.warningGroupId(),
        parseRunMode(req.runMode()),
        new WorkerGroup(req.workerGroup() == null ? "default" : req.workerGroup()),
        new EnvironmentCode(req.environmentCode() == null ? 0L : req.environmentCode()),
        new IdempotencyKey(req.idempotencyKey())
    );

    var saved = startWorkflowUseCase.execute(cmd);
    return ApiResponse.ok(new CommandAcceptedDto(saved.commandId(), saved.type().name(), "QUEUED", Instant.now()));
  }

  // Existing endpoints kept as stubs for now
  @GetMapping("/process-instance/list")
  public ApiResponse<PageResponse<WorkflowInstanceDto>> listInstances(@PathVariable long projectCode,
                                                                     @RequestParam(defaultValue = "1") int pageNo,
                                                                     @RequestParam(defaultValue = "10") int pageSize,
                                                                     @RequestParam(required = false) Long processDefinitionCode) {
    var items = List.of(new WorkflowInstanceDto(10001L, 900001L, 1, "RUNNING", Instant.now(), null));
    return ApiResponse.ok(new PageResponse<>(1, pageNo, pageSize, items));
  }

  @PostMapping("/execute")
  public ApiResponse<Void> control(@PathVariable long projectCode,
                                   @RequestParam long processInstanceId,
                                   @RequestParam String executeType) {
    return ApiResponse.ok(null);
  }

  // Debug endpoint for Step 1.4a only
  @GetMapping("/debug/commands")
  public ApiResponse<List<Long>> debugCommands() {
    var ids = inMemoryCommandBus.snapshot().stream().map(c -> c.commandId()).toList();
    return ApiResponse.ok(ids);
  }

  private static FailureStrategy parseFailure(String v) {
    if (v == null) return FailureStrategy.END;
    return "CONTINUE".equalsIgnoreCase(v) ? FailureStrategy.CONTINUE : FailureStrategy.END;
  }

  private static WarningType parseWarning(String v) {
    if (v == null) return WarningType.NONE;
    try { return WarningType.valueOf(v.toUpperCase()); } catch (Exception e) { return WarningType.NONE; }
  }

  private static RunMode parseRunMode(String v) {
    if (v == null) return RunMode.RUN_PARALLEL;
    try { return RunMode.valueOf(v.toUpperCase()); } catch (Exception e) { return RunMode.RUN_PARALLEL; }
  }
}
